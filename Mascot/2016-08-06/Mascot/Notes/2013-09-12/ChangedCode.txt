void PVTable_RestoreStaticConfiguration() { 
	// Remove new Lbs. 
	for(int j = ZLBLim_threshold; j < ZLBLIM; ++j) { 
		LbBead*LB = GetLbBead(j);
		LvBead*LV = LB->ZLBFirstLvBead; 
		CLEAR_LB_PTR(LV->ZLVNextLvBead, LV); 
	} 
	// Remove each vector pair that has no Lv from PVTable. 
	for(int j = ZVTLim_threshold; j < ZVTLIM; ++j) { 
		VtBead*VT = GetVtBead(j); 
		VtBead*Vt = VT->ZVTMeInreverse; 
		if(Vt->ZVTFirstCoincident == 0 && VT->ZVTFirstCoincident == 0) { 
			PVTable_REPLACE_PVBead(Vt, Vt->ZVTNextSortedVtBead, 0);
			PVTable_REPLACE_PVBead(VT, VT->ZVTNextSortedVtBead, 0);
			Vt->ZVTMeInreverse = 0; 
			VT->ZVTMeInreverse = 0; 
		} 
	} 
	// Remove new points PVTable. 
	// Since all vectors of new polygons have been removed from PVTable, 
	// A point to be removed should have only 2 vectors because it is a split of a previously existed vector. 
	for(int j = ZPTLim_threshold; j < ZPTLIM; ++j) { 
		PtBead*PT = GetPtBead(j); 
		VtBead*V1 = PT->ZPTFirstSortedVtBead; 
		VtBead*V2 = V1? V1->ZVTNextSortedVtBead: 0; 
		if(V2 && V2->ZVTNextSortedVtBead == 0) { // Only 2 vectors from the point; they also have to be ~collinear. 
			VtBead* v[2] = {V1->ZVTMeInreverse, V2->ZVTMeInreverse}; 
			VtBead* V[2] = {V2, V1}; // here v1->POINT2 <= V2->POINT1 
			for(int i = 0; i < 2; ++i) { 
				v[i]->ZVTCO2 = V[i]->ZVTCO1;
				for(LvBead*l = v[i]->ZVTFirstCoincident; l; l = l->ZLVNextConcident) { 
					l->ZLVPoint2 = v[i]->ZVTCO2; 
					LvBead*lvMarooned = l->ZLVNextLvBead; 
					if(lvMarooned->ZLVMyVector == V[i]) { // check for consistnecy
					} 
					l->ZLVNextLvBead = lvMarooned->ZLVNextLvBead; 
					lvMarooned->ZLVMyVector = 0; 
					
					LbBead*Lb = l->ZLVMyLbBead; 
					if(Lb->ZLBFirstLvBead == lvMarooned) { 
						Lb->ZLBFirstLvBead = l; 
					} 
				} 
			} 
			v[0]->ZVTMeInreverse = v[1]; 
			v[1]->ZVTMeInreverse = v[0]; 

			V1->ZVTMeInreverse = 0; 
			V2->ZVTMeInreverse = 0; 
		} 
	} 

	/*
		Remove all excessive points from hash. 
	*/ 
	CleanZPTHASH(); 

} 


bool MASCOT_IO::MASLayerAddRTPolygon(const char* name) { // This can work only with one grid-block. 
	unsigned char n = MaSCOT_IO.iLnames_hash.Exist(name); 
	if(n == 0) { 
		if(MASLayerCreateDBStorage(name)) { 
			n = MaSCOT_IO.iLnames_hash.Exist(name); 
		} 
	} 
	if(n == 0) { 
		return false; 
	} 

	long firstVt = ZVTLIM; 
	long firstPt = ZPTLIM; 

	for(long p = 0; p < ZLDLIM; ++p) {
		ZLDCO0[p] <<= S_FACTOR;
		ZLDCO1[p] <<= S_FACTOR;
	}

	C_Layer = n; 

	LbBead*Lb = Loadmaster(1); 
	if(!Lb) { 
		return false; 
	} 

	DETERMINE_CLOCKSTATUS(Lb); 

	if(STATUS == -1) {
		STATUS = 1; 
		Reverse_Lv_Chain(Lb); 
	} 

	INSERT_VECTORS(Lb); 

	POINT_VECTOR_ANALYSIS(firstVt, 0);

	return true; 
} 


